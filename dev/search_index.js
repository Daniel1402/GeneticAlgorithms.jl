var documenterSearchIndex = {"docs":
[{"location":"types/","page":"Types","title":"Types","text":"Modules = [GeneticAlgorithms]\nPages = [\"Types.jl\"]","category":"page"},{"location":"types/#GeneticAlgorithms.Chromosome","page":"Types","title":"GeneticAlgorithms.Chromosome","text":"Chromosome(genes::Vector{T})\n\nA chromosome consists of a vector of genes of type T.\n\n\n\n\n\n","category":"type"},{"location":"types/#GeneticAlgorithms.CrossoverMethod","page":"Types","title":"GeneticAlgorithms.CrossoverMethod","text":"CrossoverMethod\n\nAbstract type for crossover methods.\n\n\n\n\n\n","category":"type"},{"location":"types/#GeneticAlgorithms.MutationMethod","page":"Types","title":"GeneticAlgorithms.MutationMethod","text":"MutationMethod\n\nAbstract type for mutation methods.\n\n\n\n\n\n","category":"type"},{"location":"types/#GeneticAlgorithms.Population","page":"Types","title":"GeneticAlgorithms.Population","text":"Population(chromosomes::Vector{T})\n\nA population consists of a vector of chromosomes of type T.\n\n\n\n\n\n","category":"type"},{"location":"types/#GeneticAlgorithms.PopulationInitializationMethod","page":"Types","title":"GeneticAlgorithms.PopulationInitializationMethod","text":"PopulationInitializationMethod\n\nAbstract type for population initialization methods.\n\n\n\n\n\n","category":"type"},{"location":"types/#GeneticAlgorithms.SelectionMethod","page":"Types","title":"GeneticAlgorithms.SelectionMethod","text":"SelectionMethod\n\nAbstract type for selection methods.\n\n\n\n\n\n","category":"type"},{"location":"selection/","page":"Selection","title":"Selection","text":"Modules = [GeneticAlgorithms]\nPages = [\"Selection.jl\"]","category":"page"},{"location":"selection/#GeneticAlgorithms.RouletteWheelSelection","page":"Selection","title":"GeneticAlgorithms.RouletteWheelSelection","text":"RouletteWheelSelection <: SelectionMethod\n\nStruct for Roulette Wheel Selection. This selection method is based on the cumulative  probabilities of the fitness scores. Implemented as a callable object.\n\n\n\n\n\n","category":"type"},{"location":"selection/#GeneticAlgorithms.RouletteWheelSelection-Union{Tuple{F}, Tuple{T}, Tuple{Population{T}, Vector{Float64}}, Tuple{Population{T}, Vector{Float64}, F}} where {T<:Chromosome, F<:Function}","page":"Selection","title":"GeneticAlgorithms.RouletteWheelSelection","text":"(c::RouletteWheelSelection)(\n    population::Population{T},\n    fitness_scores::Vector{Float64},\n    rand_generator::F=rand,\n)::Tuple{T,T} where {T<:Chromosome,F<:Function}\n\nPerforms Roulette Wheel Selection on a population based on fitness scores, returning two selected individuals (parents).\n\nSelection is based on the cumulative probabilities of the fitness scores.\n\nArguments\n\npopulation::Population: The population of chromosomes from which to select.\nfitness_scores::Vector{Float64}: A vector of fitness scores corresponding to the population.\nrand_generator<:Function=rand: A function to generate random numbers, default is rand.\n\nReturn\n\nTuple{T,T}: A tuple containing two selected chromosomes (parents).\n\n\n\n\n\n","category":"method"},{"location":"optimization/#Optimizing-Genetic-Algorithms","page":"Optimization","title":"Optimizing Genetic Algorithms","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The GeneticAlgorithm struct is the Core of the module.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Modules = [GeneticAlgorithms]\nPages = [\"Optimization.jl\"]","category":"page"},{"location":"optimization/#GeneticAlgorithms.GeneticAlgorithm","page":"Optimization","title":"GeneticAlgorithms.GeneticAlgorithm","text":"GeneticAlgorithm(\n    initialization_strategy::P,\n    fitness_function::Function,\n    selection_strategy::S,\n    crossover_method::C,\n    mutation_method::M;\n    elitism::Bool=true,\n    verbose::Bool=false,\n    max_generations::Int=5,\n    mutation_rate::Float64=0.1,\n    save_best::Bool=false,\n) where {P<:PopulationInitializationMethod,S<:SelectionMethod,C<:CrossoverMethod,M<:MutationMethod}\n\nDefines a genetic algorithm with the specified parameters for selection, mutation, crossover and fitness evaluation.\n\nArguments\n\ninitialization_strategy::P: Strategy to initialize the population.\nfitness_function::Function: Function to calculate the fitness of each chromosome.\nselection_strategy::S: Strategy to select parents for crossover.\ncrossover_method::C: Method to generate offspring from selected parents.\nmutation_method::M: Method to mutate the offspring.\nelitism::Bool=true: If true, the best individual from the previous generation is carried over to the next generation.\nverbose::Bool=false: If true, additional information is printed during the execution.\nmax_generations::Int64=5: Number of generations the algorithm runs for.\nmutation_rate::Float64=0.1: Probability of mutation for each offspring in a generation.\nsave_best::Bool=false: If true, the best chromosomes and their fitness scores are saved for visualization.\n\nFields\n\ninitialization_strategy::P: Strategy to initialize the population.\nfitness_function::Function: Function to calculate the fitness of each chromosome.\nmax_generations::Int64: Number of generations the algorithm runs for.\nselection_strategy::S: Strategy to select parents for crossover.\ncrossover_method::C: Method to generate offspring from selected parents.\nmutation_method::M: Method to mutate the offspring.\nmutation_rate::Float64: Probability of mutation.\nelitism::Bool: If true, the best individual from the previous generation is carried over to the next generation.\nverbose::Bool: If true, additional information is printed during the execution.\nsave_best::Bool: If true, the best chromosomes and their fitness scores are saved for visualization.\nbest_chromosomes::Vector{Chromosome}: Stores the best chromosomes for each generation.\nbest_fitness::Vector{Float64}: Stores the fitness scores of the best chromosomes for each generation.\n\nNote that the best_chromosomes and best_fitness fields store max_generations + 1 values, including the initial population.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#GeneticAlgorithms.optimize-Tuple{GeneticAlgorithm}","page":"Optimization","title":"GeneticAlgorithms.optimize","text":"optimize(genetic_algorithm::GeneticAlgorithm)::Chromosome\n\nRuns the genetic algorithm optimization loop and returns the best Chromosome.\n\ngenetic_algorithm specifies the configuration of the genetic algorithm that is optimized. If the field genetic_algorithm.save_best is true the field genetic_algorithm.best_chromosomes  and genetic_algorithm.best_fitness are filled during the optimization process.\n\n\n\n\n\n","category":"method"},{"location":"fitness/","page":"Fitness","title":"Fitness","text":"Modules = [GeneticAlgorithms]\nPages = [\"Fitness.jl\"]","category":"page"},{"location":"fitness/#GeneticAlgorithms.rosenbrock_fitness-Tuple{Chromosome{Float64}}","page":"Fitness","title":"GeneticAlgorithms.rosenbrock_fitness","text":"rosenbrock_fitness(chromosome::Chromosome{Float64})::Float64\n\nCalculates the fitness of the chromosome regarding the Rosenbrock function.\n\nThe Rosenbrock function gets the genes of the chromosome as input. The result of the function  is transformed to a fitness value by dividing 100 by the result plus 1.  Throws an ArgumentError if the number of genes is less than 2.\n\n\n\n\n\n","category":"method"},{"location":"fitness/#GeneticAlgorithms.sudoku_fitness-Tuple{Chromosome{Vector{Int64}}}","page":"Fitness","title":"GeneticAlgorithms.sudoku_fitness","text":"sudoku_fitness(chromosome::Chromosome{Vector{Int64}})::Float64\n\nCalculates the fitness of a Sudoku puzzle represented by the chromosome.\n\nThe fitness value is the sum of the number of distinct values in each row and each 3x3 subgrid. This results in a maximal fitness value of 162.  The function expects a chromosome with 9 genes, each representing a row in the Sudoku puzzle. The genes are expected to have no duplicates and values between 1 and 9.\n\n\n\n\n\n","category":"method"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"Modules = [GeneticAlgorithms]\nPages = [\"Mutation.jl\"]","category":"page"},{"location":"mutation/#GeneticAlgorithms.RealGeneMutation","page":"Mutation","title":"GeneticAlgorithms.RealGeneMutation","text":"RealGeneMutation(mutation_rate::Float64, mutation_interval::Tuple{T,T})\n\nDefines the mutation of genes of real values.\n\nCurrently only Float64 and Integer types (including Bool) are supported. Mutation is applied for each gene on its own with probability mutation_rate. On mutation a value from the uniform distribution in the interval mutation_interval is drawn  and added to the gene. Boolian genes are inverted. \n\n\n\n\n\n","category":"type"},{"location":"mutation/#GeneticAlgorithms.SudokuMutation","page":"Mutation","title":"GeneticAlgorithms.SudokuMutation","text":"SudokuMutation(mutation_rate::Float64, initial::Vector{Vector{Int64}})\n\nMutation method for Sudoku puzzles. \n\nThe mutation is applied column-wise with probability mutation_rate. initial contains the initial sudoku grid and must be of size 9x9. The mutation ensures that the initial cells of initial are not changed and the remaining values are shuffled.\n\n\n\n\n\n","category":"type"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"Modules = [GeneticAlgorithms]\nPages = [\"Crossover.jl\"]","category":"page"},{"location":"crossover/#GeneticAlgorithms.SinglePointCrossover-Union{Tuple{C}, Tuple{C, C}} where C<:Chromosome","page":"Crossover","title":"GeneticAlgorithms.SinglePointCrossover","text":"SinglePointCrossover(parent1::C, parent2::C)::Tuple{C,C} where {C<:Chromosome}\n\nDefines the single point crossover method for two chromosomes parent1 and parent2.  Returns a tuple of the two offspring chromosomes.\n\n\n\n\n\n","category":"method"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Modules = [GeneticAlgorithms.Visualization]","category":"page"},{"location":"visualization/#GeneticAlgorithms.Visualization.print_sudoku-Tuple{Chromosome}","page":"Visualization","title":"GeneticAlgorithms.Visualization.print_sudoku","text":"print_sudoku(chromosome::Chromosome)\n\nPrints the Sudoku genes of the given chromosome. Betwee each 3x3 block, lines are drawn to separate the blocks.\n\n\n\n\n\n","category":"method"},{"location":"visualization/#GeneticAlgorithms.Visualization.visualize_function_with_contours-Tuple{Function}","page":"Visualization","title":"GeneticAlgorithms.Visualization.visualize_function_with_contours","text":"Plots a contour of a 2D function over the specified x and y ranges.\n\nArguments\n\nf::Function: The function to visualize.\nx_range: Range of x-values (default: (-2.0, 2.0)).\ny_range: Range of y-values (default: (-2.0, 2.0)).\npath: Optimization path points (default: []).\n\nReturns\n\nA contour plot of the function with optional highlighted points.\n\n\n\n\n\n","category":"method"},{"location":"visualization/#GeneticAlgorithms.Visualization.visualize_rosenbrock_results-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, String}} where T<:Chromosome","page":"Visualization","title":"GeneticAlgorithms.Visualization.visualize_rosenbrock_results","text":"visualize_rosenbrock_results(best_chromosomes::Vector{Chromosome}, save_path::String=\"result.png\")\n\nGenerates a visualization of the optimization process for the Rosenbrock fitness function with given best_chromosomes. The visualization is saved to the specified save_path.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeneticAlgorithms","category":"page"},{"location":"#GeneticAlgorithms","page":"Home","title":"GeneticAlgorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeneticAlgorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"population_initialization/","page":"Population Initialization","title":"Population Initialization","text":"Modules = [GeneticAlgorithms]\nPages = [\"PopulationInitialization.jl\"]","category":"page"},{"location":"population_initialization/#GeneticAlgorithms.RealUniformInitialization","page":"Population Initialization","title":"GeneticAlgorithms.RealUniformInitialization","text":"RealUniformInitialization(population_size::Int64, chromosome_size::Int64, interval::Tuple{T,T})\n\nRealUniformInitialization(population_size::Int64, chromosome_size::Int64, intervals::Vector{Tuple{T,T}})\n\nCreates a population of population_size including chromosomes of chromosome_size.  The chromosome-values are drawn from a uniform distribution over interval. In the second constructor, the intervals vector specifies the interval for each gene. The current implementation supports Float64 and Integer types.  The type is determined by the interval. The struct must be called to create a population.\n\n\n\n\n\n","category":"type"},{"location":"population_initialization/#GeneticAlgorithms.RealUniformInitialization-Union{Tuple{}, Tuple{T}} where T<:Float64","page":"Population Initialization","title":"GeneticAlgorithms.RealUniformInitialization","text":"(c::RealUniformInitialization{T})()::Population{Chromosome{T}} where {T<:Float64}\n\nCreates a population with Float genes.\n\n\n\n\n\n","category":"method"},{"location":"population_initialization/#GeneticAlgorithms.RealUniformInitialization-Union{Tuple{}, Tuple{T}} where T<:Integer","page":"Population Initialization","title":"GeneticAlgorithms.RealUniformInitialization","text":"(c::RealUniformInitialization{T})()::Population{Chromosome{T}} where {T<:Integer}\n\nCreates a population with Integer genes.\n\n\n\n\n\n","category":"method"},{"location":"population_initialization/#GeneticAlgorithms.SudokuInitialization","page":"Population Initialization","title":"GeneticAlgorithms.SudokuInitialization","text":"SudokuInitialization(population_size::Int64, initial::Vector{Vector{Int64}})\n\nCreates a population of population_size including chromosomes of 9x9 size.  Each gene resembles a column in a Sudoku puzzle. The initial values are taken from the initial grid.  initial must be of size 9x9. The remaining values are filled with the missing random values.  The initialization ensure that each column contains the values 1-9 exactly once.\n\n\n\n\n\n","category":"type"},{"location":"population_initialization/#GeneticAlgorithms.SudokuInitialization-Tuple{}","page":"Population Initialization","title":"GeneticAlgorithms.SudokuInitialization","text":"(c::SudokuInitialization)()::Population{Chromosome{Vector{Int64}}}\n\nThe population is created by calling the SudokuInitialization object.\n\n\n\n\n\n","category":"method"},{"location":"example/#Getting-Started-with-GeneticAlgorithms.jl","page":"Getting Started","title":"Getting Started with GeneticAlgorithms.jl","text":"","category":"section"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"Genetic algorithms (GAs) are a class of optimization algorithms inspired by the principles of natural selection and evolution. They are particularly useful for solving complex optimization problems where traditional methods may struggle. In this guide, we'll walk through two examples of using the GeneticAlgorithms.jl package: optimizing the Rosenbrock function and solving a Sudoku puzzle.","category":"page"},{"location":"example/#Optimization-Loop","page":"Getting Started","title":"Optimization Loop","text":"","category":"section"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"Genetic algorithms follow an iterative process:","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"Initialization - Generate an initial population of candidate solutions.\nEvaluation - Assess the fitness of each candidate.\nSelection - Choose individuals based on their fitness.\nCrossover - Combine selected individuals to create new offspring.\nMutation - Introduce random variations to maintain diversity.\nTermination - Repeat until a stopping condition is met (e.g., reaching a maximum number of generations).","category":"page"},{"location":"example/#Solving-the-Rosenbrock-Problem","page":"Getting Started","title":"Solving the Rosenbrock Problem","text":"","category":"section"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"The Rosenbrock function is a common benchmark for optimization algorithms. It is a non-convex function defined in multiple dimensions, with a global minimum that can be challenging to locate. Below is an example of using a genetic algorithm to find the minimum of the 2D Rosenbrock function.","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"using GeneticAlgorithms\n\n# Our Genetic Algorithm Configuration\nroulette_wheel_selection = RouletteWheelSelection()\n\nsingle_point_crossover = SinglePointCrossover()\n\nmutation_probability = 0.5\nmutation_interval = (-0.5, 0.5)\nreal_gene_mutation = RealGeneMutation(mutation_probability, mutation_interval)\n\npopulation_size = 10\nchromosome_size = 2     # input size for the 2D Rosenbrock function\ninit_interval = (-1.0, 1.0)   # value range for initial solutions \nuniform = RealUniformInitialization(population_size, chromosome_size, init_interval)\n\n# Bringing everything together...\nga_rosenbrock = GeneticAlgorithm(uniform,\n                                 rosenbrock_fitness,\n                                 roulette_wheel_selection,\n                                 single_point_crossover,\n                                 real_gene_mutation,\n                                 max_generations=100,\n                                 save_best=true)\n\nresult = optimize(ga_rosenbrock)    # performs the optimization steps described above\nprintln(result)\n\n# Visualization\nusing GeneticAlgorithms.Visualization\nvisualize_rosenbrock_results(ga_rosenbrock.best_chromosomes, \"rbplot.svg\")","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"We initialize a genetic algorithm with a population of 10 chromosomes and evolve them using roulette wheel selection, single point crossover, and random mutation operations. ","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"To visualize the results we can use the GeneticAlgorithms.Visualization submodule.","category":"page"},{"location":"example/#Solving-a-Sudoku-Puzzle","page":"Getting Started","title":"Solving a Sudoku Puzzle","text":"","category":"section"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"Sudoku is a constraint-satisfaction problem where the objective is to fill a 9×9 grid so that each row, column, and 3×3 subgrid contains the digits 1 through 9 without repetition. Genetic algorithms provide an alternative approach to solving Sudoku by treating each grid as a candidate solution and evolving them towards a valid completion.","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"using GeneticAlgorithms\nusing GeneticAlgorithms.Visualization   # Only for printing the puzzles\n\ninitial_puzzle = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\npopulation_size = 20\ninitStrategy = SudokuInitialization(20, initial_puzzle)\n\nroulette_wheel_selection = RouletteWheelSelection()\n\nsingle_point_crossover = SinglePointCrossover()\n\nmutation_probability = 0.1\nsudoku_mutation = SudokuMutation(mutation_probability, initial_puzzle)\n\nga = GeneticAlgorithm(initStrategy,\n                      sudoku_fitness, \n                      roulette_wheel_selection,\n                      single_point_crossover,\n                      sudoku_mutation,\n                      elitism=true,\n                      max_generations=1000,\n                      mutation_rate=0.4,\n                      save_best=true)\n\n\nresult = optimize(ga)\n\nprintln(\"Initial Sudoku Puzzle:\")\nprint_sudoku(Chromosome(initial_puzzle))\nprintln()\n\nprintln(\"Optimized Result:\")\n\nprint_sudoku(result)\nprintln()\n\n# We logged our best solutions and their fitness scores.\n# So we can access the fitness of the result by:\nresult_fitness = ga.best_fitness[end]\n\n# A solved sudoku has fitness score 162\nsolved_percentage = round(result_fitness / 162, digits=3) * 100 \n\nprintln(\"Solved the puzzle $(solved_percentage)%\")","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"In this example, we initialize our genes with the rows the passed initial_puzzle. The zeros are replaced by the missing values of the row. A Sudoku-specific mutation strategy allows the genetic algorithm to shuffle the puzzle rows with the mutation_probability. Combined with the other reproduction operators, we ensure that a row has no duplicates. The fitness function evaluates how close a solution is to a valid Sudoku grid, by counting non-duplicates in 3x3 subgrids and columns. ","category":"page"},{"location":"example/","page":"Getting Started","title":"Getting Started","text":"As we stop our optimization process after 1000 generations, there is no guarantee that the puzzle will be completely solved. ","category":"page"}]
}
